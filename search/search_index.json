{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DevOps Notes","text":"<p>Welcome to the DevOps Notes repository! This space serves as a comprehensive collection of notes, tips, and cheatsheets tailored for DevOps professionals and enthusiasts.</p>"},{"location":"#about-this-project","title":"About This Project","text":"<p>The goal of this project is to provide:</p> <ul> <li>Quick references for common DevOps tasks and tools.</li> <li>Cheatsheets for efficient command usage.</li> <li>Best practices and guides for modern DevOps workflows.</li> </ul> <p>Whether you're setting up CI/CD pipelines, managing Kubernetes clusters, or automating infrastructure, you'll find practical insights and tools here.</p>"},{"location":"#key-topics-covered","title":"Key Topics Covered","text":"<ul> <li>Kubernetes: Tips, commands, and configurations.</li> <li>CI/CD: Guides for tools like Jenkins, GitHub Actions, and more.</li> <li>Infrastructure as Code (IaC): Notes on Terraform, Ansible, and similar tools.</li> <li>Cloud Platforms: AWS, Azure, GCP, and their DevOps-related services.</li> <li>Monitoring &amp; Logging: Prometheus, Grafana, ELK stack, and more.</li> <li>Scripting &amp; Automation: Bash, Python, and PowerShell snippets.</li> </ul>"},{"location":"#contributions","title":"Contributions","text":"<p>This repository is a work in progress, and contributions are always welcome! Feel free to submit a pull request or open an issue if you have suggestions, improvements, or new topics to add.</p> <p>Happy DevOps-ing! \ud83d\ude80</p>"},{"location":"cloud/gcp/gcloud/","title":"gcloud","text":""},{"location":"cloud/gcp/gcloud/#cluster-commands","title":"cluster commands","text":"<pre><code>gcloud container clusters list\n\ngcloud container clusters get-credentials CLUSTER_NAME --region REGION --project PROJECT_ID\n\ngcloud container node-pools list  --cluster CLUSTER_NAME --region REGION\n\ngcloud container node-pools list  --cluster=CLUSTER_NAME --format=\"table(name,version,config.imageType)\" --region REGION\n\ngcloud container node-pools describe NODE-POOL_NAME --cluster=CLUSTER_NAME --region=REGION\n\ngcloud container clusters describe CLUSTER_NAME --region=REGION\n</code></pre>"},{"location":"cloud/gcp/gcloud/#storage-commands","title":"storage commands","text":"Storage commands<pre><code>gsutil ls gs://&lt;gcs_name&gt;\n\ngcloud storage cp &lt;file/folder&gt; gs://&lt;gcs_name&gt; --recursive\n</code></pre>"},{"location":"cloud/gcp/gcloud/#disk-commands","title":"disk commands","text":"<pre><code>gcloud compute disks list --filter=\"-users:*\"\n</code></pre>"},{"location":"cloud/gcp/networking/","title":"GCP Networking","text":""},{"location":"cloud/gcp/networking/#basic-gcp-networking","title":"Basic GCP networking","text":""},{"location":"cloud/gcp/networking/#articals","title":"Articals","text":"<p>Cloud NAT overview Building internet connectivity for private VMs Set up and manage network address translation with Public NAT</p>"},{"location":"dbs/mongodb/mongo/","title":"Mongodb","text":""},{"location":"dbs/mysql/mysql/","title":"Mysql","text":"<p>Add  and update recoreds</p> add<pre><code>INSERT INTO DB_NAME.TABLE_NAME (column1, column2) VALUES(value1, value2)\n</code></pre> update<pre><code>UPDATE DB_NAME.TABLE_NAME set column1=value1 WHERE column2=some_value\n</code></pre> <p>Table size</p> <pre><code>SELECT\n    table_name AS `Table`,\n    round(((data_length + index_length) / 1024 / 1024), 2) `Size in MB`\nFROM information_schema.TABLES\nWHERE table_schema = \"&lt;DATABASE&gt;\"\n    AND table_name = \"&lt;Table&gt;\";\n-- (1)\n</code></pre> <ol> <li>Shows the table size in MB, it is possible to add more /1024 to show in GB, replace <code>DATABASE</code> and <code>Table</code></li> </ol> <p>mysqldumb</p> <pre><code>mysqldump -h &lt;MYSQL_HOST&gt;--port &lt;PORT&gt; --user=&lt;USERNAME&gt; --password=&lt;PASSWORD&gt; --skip-column-statistics &lt;DB_NAME&gt; &gt; &lt;DUNMP_FILE&gt;\n#for example:\nmysqldump -h 127.0.0.1 --port 33061 --user=... --password=... --skip-column-statistics son &gt; mysql.dump\n</code></pre> <p>mysql restore</p> <pre><code>mysql -h 127.0.0.1 -u &lt;USERNAME&gt; -p&lt;PASSWORD&gt; &lt; FILE_NAME.dump\n</code></pre> <p>Actions on table</p> <pre><code>-- Definition of the table ()\nSHOW CREATE TABLE &lt;Table_name&gt;\\G;\n\n-- rename table\nRENAME TABLE &lt;current_name&gt; TO &lt;new_name&gt;;\n\n-- create new table (structure keys and indexes are copied over as well, *without data*)\nCREATE TABLE &lt;new_table&gt; LIKE &lt;exist_table&gt;;\n</code></pre>"},{"location":"dbs/vertica/vertica/","title":"Vertica","text":""},{"location":"git/understanding-git-merge/","title":"Understanding Git Merge","text":"<p>This section focuses on working with Git in local repositories. In future sections, I will demonstrate how to work with remote repositories on platforms like GitHub and GitLab.</p>"},{"location":"git/understanding-git-merge/#fast-forward-merge","title":"Fast-Forward Merge","text":"<p>Scenario</p> <p>You create a new branch <code>feature</code> from <code>master</code>, make commits, and <code>master</code> remains unchanged in the meantime.</p> <p>Diagram: <pre><code>gitGraph\n   commit id: \"A\"\n   commit id: \"B\"\n   branch feature\n   checkout feature\n   commit id: \"C\"\n   commit id: \"D\"</code></pre></p> <p>A and B are commits on <code>master</code>. - You create <code>feature</code> branch at B. - Commits C and D happen on <code>feature</code> only. - <code>master</code> has not moved beyond B since <code>feature</code> branched off.</p> <p>When you merge <code>feature</code> into <code>master</code>, Git sees that <code>master</code> can simply \"fast-forward\" to D, because <code>master</code> has no new commits of its own. The <code>master</code> pointer just moves forward to <code>D</code>.</p> <p>Commands:</p> <pre><code># Ensure you're on master\ngit checkout master\n\n# Merge feature into master with a fast-forward\ngit merge feature\n</code></pre> <p>The result is:</p> <pre><code>gitGraph\n   commit id: \"A\"\n   commit id: \"B\"\n   branch feature\n   checkout feature\n   commit id: \"C\"\n   commit id: \"D\"\n   checkout main\n   merge feature</code></pre> <p>And using git history: <pre><code>git log --oneline --graph\n</code></pre> <pre><code>gitGraph\n   commit id: \"A\"\n   commit id: \"B\"\n   commit id: \"C\"\n   commit id: \"(HEAD -&gt; master, feature) D\"</code></pre></p> <p> </p>"},{"location":"git/understanding-git-merge/#non-fast-forward-true-merge-commit","title":"Non-Fast-Forward (True Merge Commit)","text":"<p>Scenario</p> <p>You create <code>feature</code> from <code>master</code>, but while working on <code>feature</code>, someone makes additional commits directly on <code>master</code>. Now you have diverging lines of development:</p> <p>Diagram:</p> <pre><code>gitGraph\n   commit id: \"A\"\n   commit id: \"B\"\n   branch feature\n   checkout feature\n   commit id: \"C\"\n   commit id: \"D\"\n   checkout main\n   commit id: \"E\"</code></pre> <ul> <li>A and B are original commits on <code>master</code>.</li> <li>You branch <code>feature</code> from B, and make commits C and D there.</li> <li>Meanwhile, <code>master</code> has a new commit E after you branched off.</li> <li>When merging <code>feature</code> into <code>master</code>, Git can\u2019t just fast-forward because <code>master</code> has moved on separately. Instead, it creates a new merge commit:</li> </ul> <pre><code>gitGraph\n   commit id: \"A\"\n   commit id: \"B\"\n   branch feature\n   checkout feature\n   commit id: \"C\"\n   commit id: \"D\"\n   checkout main\n   commit id: \"E\"\n   merge feature\n   commit id: \"M\"</code></pre> <p>Commands:</p> <pre><code># Ensure you're on master\ngit checkout master\n\n# Merge feature into master - Git will create a new merge commit\ngit merge feature\n</code></pre> <p>Now, <code>master</code> contains a merge commit M that records both lines of history.</p> <p> </p>"},{"location":"git/understanding-git-merge/#handling-merge-conflicts","title":"Handling Merge Conflicts","text":"<p>Scenario</p> <p>While merging, you may encounter a conflict if both <code>master</code> and <code>feature</code> modify the same portion of a file differently. Git will stop the merge and prompt you to resolve the conflict manually.</p> <p>Diagram:</p> <pre><code>gitGraph\n    commit id:\"some-text\"\n    branch feature\n    checkout main\n    commit id:\" changes line 2\"\n    checkout feature\n    commit id: \"changes line 2\"\n    checkout main\n    merge feature tag: \"conflict\" type:REVERSE</code></pre> <p>When merging, Git finds that <code>Line 2</code> was changed in both branches but with different content.</p> <pre><code># Ensure you're on master\ngit checkout master\n\n# Merge feature into master - Git will create a new merge commit\ngit merge feature\n</code></pre> <p>Git stops and reports a conflict. Open the conflicted file. You\u2019ll see conflict markers like this:</p> <pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\nLine 2 changed in master\n=======\nLine 2 changed in feature\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature\n</code></pre> <p>Choose how to resolve the conflict. For example, if you decide to keep feature\u2019s change:</p> <pre><code>Line 1\nLine 2 changed in feature\nLine 3\n</code></pre> <p>After fixing conflicts, stage the resolved files adn commit:</p> <pre><code>git add &lt;file_name&gt;\ngit commit\n</code></pre> <p>And the result:</p> <pre><code>gitGraph\n    commit id:\"some-text\"\n    branch feature\n    checkout main\n    commit id:\" changes line 2\"\n    checkout feature\n    commit id: \"changes line 2\"\n    checkout main\n    merge feature\n    commit id:\"merge commit\"</code></pre>"},{"location":"git/understanding-git-remotes/","title":"Understanding Git Remotes","text":"<p>Git remotes are simply references (pointers) to remote repositories\u2014usually hosted on platforms like GitHub\u2014that allow you to collaborate on code, fetch updates from others, and push your own changes.</p>"},{"location":"git/understanding-git-remotes/#cloning-a-repository-and-checking-remotes","title":"Cloning a Repository and Checking Remotes","text":"<ul> <li> <p>Clone from GitHub    Suppose you run:    <pre><code>git clone https://github.com/username/example-repo.git\n</code></pre>    This command copies the remote repository to your local machine.</p> </li> <li> <p>Check Remotes    After the clone is complete, navigate into the project folder:    <pre><code>cd example-repo\n</code></pre>    Then run:    <pre><code>git remote -v\n</code></pre></p> </li> <li>The <code>-v</code> flag stands for \"verbose\" and shows you the list of remote connections and their corresponding URLs. You typically see something like:      <pre><code>origin  https://github.com/username/example-repo.git (fetch)\norigin  https://github.com/username/example-repo.git (push)\n</code></pre><ul> <li>Origin is the default name Git assigns to the main remote repository you cloned from.</li> <li>This means your local repo is linked to that remote URL.  </li> </ul> </li> </ul> <p>When you use <code>git pull</code>, Git automatically fetches and merges changes from the origin remote by default (unless you specify otherwise), meaning it pulls updates from that URL.</p>"},{"location":"git/understanding-git-remotes/#creating-a-new-local-repository-and-connecting-to-github","title":"Creating a New Local Repository and Connecting to GitHub","text":"<p>If you've ever tried to create a new empty repository on GitHub, you've probably seen these instructions:</p> <p></p> <p>As you can see, it adds a remote to the local Git repository</p> <ol> <li> <p>Initialize Local Repository    First, create a new project folder and initialize Git:    <pre><code>mkdir new-project\ncd new-project\ngit init\n</code></pre>    This creates an empty local Git repository in the <code>new-project</code> folder.</p> </li> <li> <p>Create a New Repo on GitHub    Go to GitHub, create a new repository, and copy its remote URL (for example, <code>https://github.com/username/new-project.git</code>).</p> </li> <li> <p>Add the Remote    Back in your local terminal, you add your GitHub repository as the origin remote:    <pre><code>git remote add origin https://github.com/username/new-project.git\n</code></pre> Explanation: <code>git remote add origin &lt;URL&gt;</code> associates the name origin with the remote repository you just created on GitHub. This is the link between your local repo and the remote repo.</p> </li> <li> <p>Verify the Remote    Use the <code>git remote -v</code> command again:    <pre><code>git remote -v\n</code></pre>    You should now see something like:    <pre><code>origin  https://github.com/username/new-project.git (fetch)\norigin  https://github.com/username/new-project.git (push)\n</code></pre>    you can add some remotes to the same repository:    <pre><code>git remote add gitlab https://gitlab.com/yoad787/argocd-test.git\n</code></pre> <pre><code>git remote -v\n\n# And the result:\ngitlab  https://gitlab.com/yoad787/argocd-test.git (fetch)\ngitlab  https://gitlab.com/yoad787/argocd-test.git (push)\norigin  git@github.com:Yoad-Duani/personal_notes.git (fetch)\norigin  git@github.com:Yoad-Duani/personal_notes.git (push)\n</code></pre></p> </li> <li> <p>Push Your Code    Now you can push changes to your GitHub repo:    <pre><code>git push origin &lt;branch_name&gt;\n</code></pre>    This command sends your local commits from <code>&lt;branch_name&gt;</code> to the origin remote on GitHub.</p> </li> </ol>"},{"location":"git/understanding-git-remotes/#default-branch-considerations","title":"Default Branch Considerations","text":"<p>By default, many local Git installations name the initial branch master, whereas GitHub (and other platforms) may default to a branch named main. To rename the local branch to main, you can use:</p> <pre><code>git branch -M main\n</code></pre> <p>This renames the current branch to main so that it matches the default naming convention on GitHub.</p>"},{"location":"git/understanding-git-remotes/#understanding-git-push","title":"Understanding Git Push","text":"<p>When you run a command like:</p> <pre><code>git push origin &lt;branch_name&gt;\n</code></pre> <p>you're sending (pushing) commits from your local <code>&lt;branch_name&gt;</code> to the remote repository (usually referred to as <code>origin</code>) on the same branch name (if you specify <code>&lt;branch_name&gt;</code> on both sides). For instance:</p> <pre><code>git push origin main\n</code></pre> <p>pushes your local main branch to the remote main branch on <code>origin</code>.</p>"},{"location":"git/understanding-git-remotes/#pushing-local-branch-to-a-different-remote-branch","title":"Pushing Local Branch to a Different Remote Branch","text":"<p>You don't necessarily have to push your local branch to the same remote branch name. For example, to push your local <code>feature2</code> branch into the remote main branch, you can use:</p> <pre><code>git push origin feature2:main\n</code></pre> <p>This will cause the branch <code>feature2</code> on your local to be published to the remote repository as <code>main</code>.</p>"},{"location":"git/understanding-git-remotes/#setting-upstream-with-git-push-u","title":"Setting Upstream with <code>git push -u</code>","text":"<p>Often, you want to link (or set upstream) between your local branch and a specific remote branch, so that you can simply type:</p> <pre><code>git push\n</code></pre> <p>without specifying the remote name and branch every time. You can do this with:</p> <pre><code>git push -u origin main\n</code></pre> <p>The <code>-u</code> (or <code>--set-upstream</code>) flag sets your local main branch to track the main branch on <code>origin</code>. That way, if you are on your local main branch, you only need to type <code>git push</code> in the future.</p> <p>NOTE:  When you clone a repo, git take care for the default remote branch and link it to your local branch (usually <code>main</code> -&gt; <code>origin/main</code>)  see Understanding Remote Tracking Branches</p> <p>Error When No Upstream Is Set</p> <p>If you try to push a branch that doesn't have an upstream set yet, you'll see an error like:</p> <pre><code>fatal: The current branch main has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n    git push --set-upstream origin main\n</code></pre> <p>This simply means you need to tell Git where to push your local commits for that branch. Running the suggested command will set the upstream for the main branch on your local machine.</p> <p>Example Output</p> <p>When you successfully push, you might see output similar to:</p> <pre><code>..\n..\nTo https://github.com/username/my-repo.git\n * [new branch]      main -&gt; main\n</code></pre> <p><code>main -&gt; main</code> meaning that your local main branch pushed to remote main branch.</p> <p> </p>"},{"location":"git/understanding-git-remotes/#understanding-remote-tracking-branches","title":"Understanding Remote Tracking Branches","text":"<p>When you clone a repository or set up a new remote, Git automatically creates remote tracking branches. These are references in your local repository that track the state of remote branches. For example, <code>origin/main</code> is a remote tracking branch that represents the main branch on your remote named <code>origin</code>.</p>"},{"location":"git/understanding-git-remotes/#how-remote-tracking-branches-work","title":"How Remote Tracking Branches Work","text":"<p>A remote tracking branch like <code>origin/main</code> is not an actual local branch that you can directly commit to. Instead, it updates whenever you do a <code>git fetch</code> or <code>git pull</code> to show the latest state of the remote's main branch.</p> <p>Locally, when you run <code>git log --oneline --graph</code>  You might see something like this:</p> <pre><code>e0d3332 (HEAD -&gt; main, origin/main)\n</code></pre> <p>This means: - HEAD -&gt; main: You are currently on the local main branch. - origin/main: The remote tracking branch (for your <code>origin</code> remote) is at the same commit (here, <code>e0d3332</code>), indicating your local main is in sync with the remote\u2019s main branch.</p>"},{"location":"git/understanding-git-remotes/#viewing-remote-branches","title":"Viewing Remote Branches","text":"<p>You can see what remote branches exist by running:</p> <pre><code>git branch -r\n</code></pre> <p>This command lists remote branches, such as: <pre><code>  origin/main\n  origin/develop\n  origin/featureX\n</code></pre></p> <p>Any remote tracking branch that appears here has a corresponding branch in the remote repository.  To get one of these branches locally, and start to work on that you can just run switch:</p> <pre><code>git switch featureX\n</code></pre> <p>This will create a new local branch <code>featureX</code> and set it up to track the remote branch <code>origin/featureX</code></p> <p>NOTE: The old command used in the past: <pre><code>git checkout --track origin/featureX\n</code></pre></p> <p>so now when you run</p> <pre><code>git branch\n# You will see the new local branch featureX\nmain\nfeatureX\n</code></pre> <p> </p>"},{"location":"git/understanding-git-stash/","title":"Understanding Git Stash","text":""},{"location":"git/understanding-git-stash/#simple-git-stash","title":"Simple git stash","text":"<p>Explanation</p> <ul> <li><code>git stash</code>: Temporarily saves your changes without committing them.</li> <li><code>git stash pop</code>: Applies the stash and removes it from the stash list.</li> <li><code>git stash apply</code>: Applies the stash but keeps it in the stash list.</li> </ul> <p>Commands</p> <pre><code>git stash          # Save changes to the stash\n# Make sure your working directory is clean before popping or applying\n\ngit stash pop      # Apply the stash and remove it\n# OR\ngit stash apply    # Apply the stash but keep it in the stash list\n</code></pre>"},{"location":"git/understanding-git-stash/#working-with-multiple-stashes","title":"Working with Multiple Stashes","text":"<p>Explanation</p> <ul> <li><code>git stash list</code>: View all saved stashes.</li> <li>Named Stash: Add a name for easy identification.</li> <li>Apply Specific Stash: Use the stash name or ID.</li> </ul> <p>Commands</p> <pre><code>git stash push -m \"Feature work\"                        # Stash named stash\n\ngit stash push -m \"Feature work\" --include-untracked    # Stash untracked files\n\ngit stash push -m \"Feature work\" -S                     # Stash staged files\n\ngit stash list                                          # List all stashes\n\n# Apply a specific stash\ngit stash apply stash@{1}                               # Apply stash by ID\n\ngit stash pop stash@{1}                                 # Apply and remove stash by ID\n\n# Apply a specific stash by name\ngit stash apply \"stash^{/Feature work}\"                 # Apply stash by name\n</code></pre>"},{"location":"git/understanding-git-stash/#resolving-conflicts-with-stash","title":"Resolving Conflicts with Stash","text":"<p>Explanation</p> <ul> <li>Sometimes applying or popping a stash can lead to conflicts if the working directory has changes that conflict with the stashed changes.</li> <li>Git will notify you of the conflict, and you must manually resolve it.</li> </ul> <p>Commands <pre><code>git stash pop                        # Attempt to pop the stash\n# If there are conflicts, Git will notify you\n\n# Resolve the conflicts manually using your editor or Git tools\n\n# After resolving the conflicts\n\ngit add &lt;file&gt;                       # Stage the resolved files\n\ngit stash drop                       # Drop the stash if it was successfully applied\n</code></pre></p>"},{"location":"git/understanding-git-stash/#remove-stash","title":"Remove stash","text":"<p>Explanation</p> <ul> <li><code>git stash drop</code>: Remove a specific stash.</li> <li><code>git stash clear</code>: Remove all stashes.</li> </ul> <p>Commands <pre><code>git stash drop stash@{1}            # Drop a specific stash\n\ngit stash clear                     # Clear all stashes\n</code></pre></p> <p></p>"},{"location":"git/understanding-git-stash/#full-example","title":"Full Example","text":""},{"location":"git/understanding-undo-time-traveling/","title":"Understanding Time Traveling In Git","text":"<p>In Git, there are various ways to move through commit history, undo changes, and revert your project to previous states. This guide explains different scenarios, including diagrams that illustrate how Git operations work behind the scenes.</p> <p>This section focuses on working with Git in local repositories. In future sections, I will demonstrate how to work with remote repositories on platforms like GitHub and GitLab.</p>"},{"location":"git/understanding-undo-time-traveling/#checking-out-a-specific-commit","title":"Checking Out a Specific Commit","text":"<p>When you run:</p> <pre><code>git checkout &lt;commit-hash&gt;\n</code></pre> <p>Git will move <code>HEAD</code> to point directly to that commit. This is known as a detached HEAD state because you\u2019re no longer on a branch,but rather pointing to a specific commit.  Any commits you make in this state will not belong to any branch until you either create a new branch or re-attach <code>HEAD</code> to an existing branch.</p> <p>Detached HEAD:</p> <pre><code>gitGraph\n   commit id: \"Commit A (cA)\"\n   commit id: \"Commit B (cB)\"\n   commit id: \"Commit C (cC)\" tag: \"main\"\n   commit id: \"Commit D (cD)\"\n   commit id: \"Commit E (cE)\" tag: \"HEAD (detached)\"</code></pre> <p><code>git checkout &lt;commit-hash-of-cE&gt;</code> checks out <code>Commit E</code> directly. <code>HEAD</code> is now detached at <code>Commit E</code>.</p> <p>To get back onto a branch (e.g., main), you can run:</p> <pre><code>git checkout main\n</code></pre> <p>Now <code>HEAD</code> points back to the tip of main. Another option is to create a new branch from the detached commit:</p> <pre><code>git checkout -b my-new-branch\n</code></pre> <p>This creates and switches you to <code>my-new-branch</code>, attaching <code>HEAD</code> to that branch.</p> <p>Referencing Commits Relative to <code>HEAD</code></p> <p><code>HEAD</code> represents the tip of the current branch. You can reference commits relative to <code>HEAD</code> using notation like <code>HEAD~1</code>, Which means the parent of <code>HEAD</code>, or <code>HEAD~2</code>, which is the grandparent, and so on.</p> <p>For example:</p> <ul> <li><code>HEAD~1</code> is the commit just before your current <code>HEAD</code>.</li> <li><code>HEAD~2</code> is two commits before <code>HEAD</code>.</li> </ul> <pre><code>gitGraph\n   commit id: \"Commit 1\"tag: \"HEAD~2\"\n   commit id: \"Commit 2\" tag: \"HEAD~1\"\n   commit id: \"Commit 3\" tag: \"HEAD\"</code></pre> <p><code>HEAD</code> points to Commit 3. <code>HEAD~1</code> would point to Commit 2. <code>HEAD~2</code> would point to Commit 1.</p> <p>This is useful for operations like resetting, checking out, or restoring files.</p>"},{"location":"git/understanding-undo-time-traveling/#discarding-changes-in-a-file","title":"Discarding Changes in a File","text":"<p>Sometimes you edit a file in your working directory but decide you no longer want those changes. You can revert it back to the version in <code>HEAD</code> (your latest commit).</p> <pre><code>git checkout HEAD &lt;filename&gt;\n</code></pre> <p>This command replaces the file in your working directory with the version in HEAD. Alternatively, the older short form is:</p> <pre><code>git checkout -- &lt;filename&gt;\n</code></pre> <p>In newer Git versions, you can achieve the same effect with:</p> <pre><code>git restore &lt;filename&gt;\n</code></pre> <p>This discards all local changes (change that did not added yet) in <code>&lt;filename&gt;</code> since the last commit on the current branch.</p>"},{"location":"git/understanding-undo-time-traveling/#restoring-files-to-a-specific-commit","title":"Restoring Files to a Specific Commit","text":"<p>You can restore a file to its state in a specific commit (e.g., <code>HEAD~1</code>) using:</p> <pre><code>git restore --source HEAD~1 &lt;filename&gt;\n</code></pre> <p>This does not move <code>HEAD</code>; it only updates the file in your working directory to the state it had in <code>HEAD~1</code>.</p> <pre><code>gitGraph\n   commit id: \"Old Commit\" tag: \"HEAD~1\"\n   commit id: \"Current Commit\" tag: \"HEAD\"\n</code></pre> <p>You\u2019re simply pulling the file\u2019s contents from \u201cOld Commit (HEAD~1)\u201d into your working directory while staying on \u201cCurrent Commit (HEAD)\u201d.</p> <p>Returning the File to HEAD:  If you later change your mind and want the version from HEAD again, just run:</p> <pre><code>git restore &lt;filename&gt;\n</code></pre>"},{"location":"git/understanding-undo-time-traveling/#unstaging-files","title":"Unstaging Files","text":"<p>If you\u2019ve staged a file by running <code>git add &lt;filename&gt;</code> but then decide you don\u2019t want it in the staging area, you can unstage it with:</p> <pre><code>git restore --staged &lt;filename&gt;\n</code></pre> <p>This removes <code>&lt;filename&gt;</code> from the staging area but leaves your working directory changes intact.</p>"},{"location":"git/understanding-undo-time-traveling/#resetting-commits","title":"Resetting Commits","text":"<p><code>git reset</code> moves the <code>HEAD</code> (and possibly the current branch pointer) to a specified commit.</p> <pre><code>git reset &lt;commit-hash&gt;\n</code></pre> <p>By default, <code>git reset &lt;commit-hash&gt;</code> is a mixed reset, which moves <code>HEAD</code> to <code>&lt;commit-hash&gt;</code> and unstages any changes that were staged in later commits. However, it usually keeps changes in your working directory.</p> <p>Before:</p> <pre><code>gitGraph\n    commit id: \"Older Commit\"\n    commit id: \"Target Commit\"\n    commit id: \"New Commit\" tag: \"HEAD\"\n</code></pre> <p>After:</p> <p><pre><code>gitGraph\n    commit id: \"Older Commit\"\n    commit id: \"Target Commit\" tag: \"HEAD\"\n</code></pre> If you now run <code>git status</code> you will see unstages files</p> <p>If you now run:</p> <pre><code>git log --graph --oneline\n</code></pre> <p>You might see the \"New Commit\" commit is no longer reachable from your current HEAD (unless you do further actions).</p> <p>To completely discard changes:</p> <pre><code>git reset --hard &lt;commit-hash&gt;\n</code></pre> <p>A hard reset discards all changes in both the staging area and your working directory, forcing them to match exactly what\u2019s in <code>&lt;commit-hash&gt;</code>. Use with caution, because this can permanently destroy local changes if they haven\u2019t been committed anywhere else.</p>"},{"location":"git/understanding-undo-time-traveling/#reverting-commits","title":"Reverting Commits","text":"<p>To create a new commit that undoes changes introduced by a previous commit, use:</p> <pre><code>git revert &lt;commit-hash&gt;\n</code></pre> <p>Unlike <code>git reset</code>, <code>git revert</code> is safe for shared branches because it does not modify commit history. Instead, it creates a new commit that reverses the changes.</p> <p>Before:</p> <pre><code>gitGraph\n    commit id: \"Good Commit\"\n    commit id: \"Buggy Commit\" tag: \"HEAD\"\n</code></pre> <p>After:</p> <pre><code>gitGraph\n    commit id: \"Good Commit\"\n    commit id: \"Buggy Commit\"\n    commit id: \"Revert Commit\" tag: \"HEAD\"\n</code></pre> <p>Why Use <code>git revert</code>?</p> <ul> <li>Use <code>git revert</code> for shared branches to maintain a linear commit history.</li> <li>Use <code>git reset</code> for local branches when you need to rewrite history.  (This can be useful for removing secrets remotely, which will be described in the next sections)</li> </ul>"},{"location":"git/working-with-remotes/","title":"Working With Remotes","text":""},{"location":"git/working-with-remotes/#checking-out-remote-tracking-branches","title":"Checking Out Remote Tracking Branches","text":"<p>Let's say we have the following scenario:  You cloned the main branch (clone a repo) and made two new commits to your local branch. This means your remote branch (origin/main) is two commits behind.</p> <pre><code>gitGraph\n    commit id: \"A\"\n    commit id: \"B\"\n    commit id: \"C\" tag: \"origin/main\"\n    commit id: \"D\"\n    commit id: \"E\" tag: \"main\"\n</code></pre> <p>The remote tracking branch <code>origin/main</code> point to commit <code>C</code> and your local main branch point to commit <code>E</code></p> <p>if you will run <code>git status</code> you will see something like:</p> <pre><code>Your branch is ahead of 'origin/main by 2 commits.\n</code></pre> <p>If you want see the state of the <code>origin/main</code>,  A bookmark to the tracking branch state before the commits, last your a re communicate with GitHub</p> <pre><code>git checkout origin/main\n</code></pre> <p>This will enter you to <code>detached HEAD</code> state  To switch back to your local main branch</p> <pre><code>git checkout main\n</code></pre> <p>\u26a0\ufe0f NOTE: <code>git checkout main</code> and <code>git checkout origin/main</code> are not the same</p> <p>And if you want to push your changes</p> <pre><code>git push main\n</code></pre>"},{"location":"git/working-with-remotes/#git-fetch-and-git-pull","title":"Git Fetch and Git Pull","text":"<p>Here is a basic diagram illustrating the \"locations\" to help you understand the steps.</p> <pre><code>sequenceDiagram\n    Workspace-&gt;&gt;Staging: git add \n    Staging-&gt;&gt;Local Repo: git commit\n    Local Repo-&gt;&gt;Remote Repo: git push\n    Remote Repo--&gt;&gt;Local Repo: git fetch\n    Remote Repo--&gt;&gt;Workspace: git pull\n</code></pre>"},{"location":"git/working-with-remotes/#git-fetch","title":"Git Fetch","text":"<p>Git fetch update the remote tracking branch with the latest changes from the remote repository.</p> <p>Scenario You cloned a remote repository and created a new commit.  Meanwhile, your teammates pushed changes to the remote branch\u2014changes that are not yet present in your local branch.</p> <p>NOTE: At this point, the remote-tracking branch <code>origin/main</code> is not yet aware of these changes.</p> <pre><code>%%{init: { 'gitGraph': {'showBranches': true, 'showCommitLabel':true,'mainBranchName': 'On-GitHub'}} }%%\ngitGraph\n    commit id: \"A\"\n    commit id: \"B\"\n    commit id: \"C\"\n    commit id: \"D\"\n    commit id: \"E\"</code></pre> <pre><code>%%{init: { 'gitGraph': {'showBranches': true, 'showCommitLabel':true,'mainBranchName': 'Local'}} }%%\ngitGraph\n    commit id: \"A\"\n    commit id: \"B\" tag: \"origin/main\"\n    commit id: \"New-1\" tag: \"main\"</code></pre> <p>If You don't want to screw up your working directory, but still want to have access to this changes,  You can use git fetch:</p> <pre><code>git fetch origin\n\n# If you have only one origin\ngit fetch\n\n# Or if you want fetch only one branch\ngit fetch origin main\n</code></pre> <pre><code>%%{init: { 'gitGraph': {'showBranches': true, 'showCommitLabel':true,'mainBranchName': 'main'}} }%%\ngitGraph\n    commit id: \"A\"\n    commit id: \"B\"\n    branch origin/main\n    checkout main\n    commit id: \"New-1\" tag: \"HEAD\"\n    checkout origin/main\n    commit id: \"C\"\n    commit id: \"D\"\n    commit id: \"E\" tag: \"origin/main\"\n</code></pre> <p>These change will not appear in your local directory (Workspace)  And you will not see them in <code>git log --oneline --graph</code> unless you will run  <code>git log origin/main --oneline --graph --decorate</code>  But if you will run <code>git status</code> You will see something like:</p> <pre><code>Your branch is behind 'origin/main' by 3 commits, ...\n</code></pre> <p>And if I want see these changes:</p> <pre><code>git checkout origin/main\n</code></pre> <p>This will enter you to <code>detached HEAD</code> state (and you can create new brach from this state if you want)  To switch back:</p> <pre><code>git checkout main\n</code></pre> <p>You can merge the changes if you want by run</p> <p><pre><code># assuming you on the main branch\ngit merge origin/main\n</code></pre> But I will explain it in more depth in the upcoming sections.</p>"},{"location":"git/working-with-remotes/#git-pull","title":"Git Pull","text":"<p>Update your current branch with whatever changes are on the remote tracking branch.  so basically <code>git pull</code> = <code>git fetch</code> + <code>git merge</code></p> <p>To pull, we specify the particular remote branch we want to pull using</p> <pre><code>git pull ROMOTE BRANCH\n</code></pre> <p>Just like <code>git merge</code>, its matter where we run this command from.  Whatever branch we run it from is where the changes will be merge into.  <code>git pull origin main</code> would fetch the lates information from the origin main branch, And merge those changes into our current branch</p> <p>Scenario without conflict You have a local repository with a <code>main</code> branch that you cloned.  Commits <code>A</code> and <code>B</code> are the initial commits.</p> <pre><code>gitGraph\n    commit id: \"A\"\n    commit id: \"B\" tag: \"main, origin/main\"</code></pre> <p>Your teammate pushes new commits <code>C</code> and <code>D</code> to the remote <code>main</code> branch.</p> <pre><code>%%{init: { 'gitGraph': {'showBranches': true, 'showCommitLabel':true,'mainBranchName': 'On-GitHub'}} }%%\ngitGraph\n    commit id: \"A\"\n    commit id: \"B\"\n    commit id: \"C\"\n    commit id: \"D\"</code></pre> <p>You want to update your local <code>main</code> branch with those changes.  by running <code>git pull origin main</code></p> <p><pre><code>gitGraph\n   commit id: \"A\"\n   commit id: \"B\"\n   commit id: \"C\"\n   commit id: \"D\" tag: \"main, origin/main\"</code></pre> Commits <code>C</code> and <code>D</code> from the remote <code>origin/main branch</code> are fetched and merged into the <code>local main branch</code>. Git sees that <code>main</code> can simply \"fast-forward\" to <code>D</code>, because <code>main</code> has no new commits of its own. The <code>main</code> pointer just moves forward to <code>D</code>.</p> <p></p> <p>Scenario with conflict </p>"},{"location":"kubernetes/helm/","title":"Helm","text":""},{"location":"kubernetes/helm/#helm-repos","title":"Helm repos","text":"Add repo<pre><code>helm repo add MY_REPO_NAME REPO_URL\n</code></pre> List repos<pre><code>helm repo list\n</code></pre> Search chart<pre><code>helm search repo REPO_NAME -l\n</code></pre> Pull chart<pre><code>helm pull repo REPO_NAME/CHART_NAME --version VERSION\n</code></pre>"},{"location":"kubernetes/kubectl/","title":"Kubectl","text":"Cleanup old contexts and clusters<pre><code>kubectl config get-contexts -o name\n\nkubectl config get-contexts -o name | grep 'old-context' | xargs -n 1 kubectl config delete-context\n\nkubectl config get-clusters -o name\n\nkubectl config get-clusters -o name | grep 'old-cluster' | xargs -n 1 kubectl config delete-cluster\n\nkubectl config get-users -o name\n\nkubectl config delete-user USERNAME\n</code></pre>"},{"location":"kubernetes/kustomize/","title":"kustomize","text":"<p>Kustomize.io kustomize tutorial Kustomize example</p>"},{"location":"kubernetes/kustomize/#kustomize-basic","title":"kustomize basic","text":"Add repo List repos Search chart Pull chart"},{"location":"linux/startup-ubuntu/","title":"Ubuntu Bastion Script","text":"<pre><code>#!/usr/bin/env bash\n####################\n##  Ubuntu setup  ##\n####################\n\nANSIBLE_VERSION=\"8.1.0\"\nTERRAFORM_VERSION=\"1.5.2\"\nTERRAGRUNT_VERSION=\"v0.45.11\"\nVENV_PATH=~/virtualenv\n\n#### Install ZSH\n# apt update\nsudo apt clean\nsudo apt update -y\n#sudo apt -y upgrade\nsudo apt-get install zsh -y\n\n#install git\nsudo apt-get install git -y\n\n#install oh-my-zsh\nsh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\n\ncat &lt;&lt; EOF &gt;&gt; ~/.zshrc\nif test -t 1; then\nexec zsh\nfi\n\nZSH_THEME=\"agnoster\"\nZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=60'\nEOF\n\nsource ~/.zshrc\n\n# using dircolors.ansi-dark\ncurl https://raw.githubusercontent.com/seebi/dircolors-solarized/master/dircolors.ansi-dark --output ~/.dircolors\n\n## set colors for LS_COLORS\ncat &lt;&lt; EOF &gt;&gt; ~/.zshrc\neval `dircolors ~/.dircolors`\nEOF\n\n\n\n\n\n# Additional packages\nsudo apt -y install git \\\n         unzip \\\n         wget \\\n         python3 \\\n         python3-venv \\\n         nfs-common \\\n         openjdk-11-jdk \\\n         dnsutils \\\n         net-tools \\\n         python3-pip\n\npython3 -m venv ${VENV_PATH}\nsource ${VENV_PATH}/bin/activate\n\n# Symbolic links for SELinux\n# cd ${VENV_PATH}/lib/python3.9/site-packages/\n# sudo ln -s /usr/lib/python3/dist-packages/selinux\n# sudo ln -s /usr/lib/python3/dist-packages/_selinux.cpython-39-x86_64-linux-gnu.so\n\n# Upgrade pip and install required Python packages\npip install --upgrade pip\npip install --upgrade cython rust setuptools-rust cryptography setuptools google-api-python-client jmespath\npip install ansible==${ANSIBLE_VERSION}\nsource ${VENV_PATH}/bin/deactivate\n\n# git clone https://github.com/jotyGill/ezsh.git\n# cd ezsh\n# ./install.sh -c\n\n#### Terraform Installation\nif [[ -f /usr/local/bin/terraform ]]; then\n    echo \"/usr/local/bin/terraform exists. doing nothing\"\nelse\n    echo \"--- Installing Terraform(${TERRAFORM_VERSION}) ---\"\n    curl -L https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_amd64.zip &gt; /tmp/terraform_${TERRAFORM_VERSION}_linux_amd64.zip\n    unzip /tmp/terraform_${TERRAFORM_VERSION}_linux_amd64.zip -d /tmp/\n    sudo mv /tmp/terraform /usr/local/bin/terraform\n    sudo chmod 755 /usr/local/bin/terraform\n    sudo rm -rf /tmp/terraform_${TERRAFORM_VERSION}_linux_amd64.zip\nfi\n\n#### Terragrunt Installation\nif [[ -f /usr/local/bin/terragrunt ]]; then\n    echo \"/usr/local/bin/terragrunt exists. doing nothing\"\nelse\n    echo \"--- Installing Terragrunt(${TERRAGRUNT_VERSION}) ---\"\n    wget https://github.com/gruntwork-io/terragrunt/releases/download/$TERRAGRUNT_VERSION/terragrunt_linux_amd64\n    sudo mv terragrunt_linux_amd64 /usr/local/bin/terragrunt\n    sudo chmod 755 /usr/local/bin/terragrunt\n    sudo rm terragrunt_linux_amd64\nfi\n\n#### Add more tools binaries\n(\n    sh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"\n    git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf\n    yes | ~/.fzf/install\n    sudo apt -y install jq\n    wget https://github.com/simeji/jid/releases/download/v0.7.6/jid_linux_amd64.zip\n    unzip jid_linux_amd64.zip\n    sudo mv jid /usr/local/bin\n)\n\n#### Install kubectl + Helm\ncurl -LO \"https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\"\nsudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl\n\n#sudo apt -y install apt-transport-https\n#curl https://baltocdn.com/helm/signing.asc | sudo apt-key add -\n#sudo apt-add-repository \"deb https://baltocdn.com/helm/stable/debian/ all main\" ###\n#sudo apt -y update\n#sudo apt -y install helm\n\ncurl https://baltocdn.com/helm/signing.asc | gpg --dearmor | sudo tee /usr/share/keyrings/helm.gpg &gt; /dev/null\nsudo apt-get install apt-transport-https --yes\necho \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/helm.gpg] https://baltocdn.com/helm/stable/debian/ all main\" | sudo tee /etc/apt/sources.list.d/helm-stable-debian.list\nsudo apt-get update\nsudo apt-get install helm\n\n\n#### Krew install\nOS=\"$(uname | tr '[:upper:]' '[:lower:]')\" &amp;&amp;\nARCH=\"$(uname -m | sed -e 's/x86_64/amd64/' -e 's/\\(arm\\)\\(64\\)\\?.*/\\1\\2/' -e 's/aarch64$/arm64/')\" &amp;&amp;\nKREW=\"krew-${OS}_${ARCH}\" &amp;&amp;\ncurl -fsSLO \"https://github.com/kubernetes-sigs/krew/releases/latest/download/${KREW}.tar.gz\" &amp;&amp;\ntar zxvf \"${KREW}.tar.gz\" &amp;&amp;\n./\"${KREW}\" install krew\nexport PATH=\"${KREW_ROOT:-$HOME/.krew}/bin:$PATH\"\nkubectl krew install iexec\nkubectl krew install ctx\nkubectl krew install ns\necho 'export PATH=\"${KREW_ROOT:-$HOME/.krew}/bin:$PATH\"' &gt;&gt;~/.zshrc\n\n# zsh\n# git clone https://github.com/jotyGill/ezsh.git\n# cd ezsh\n# ./install.sh -c\n# echo \"exec zsh\" &gt;&gt;~/.bashrc\n# source ~/.zshrc\n\n#### Install argocd-cli\nwget https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64\nsudo mv argocd-linux-amd64 /usr/local/bin/argocd\nsudo chmod +x /usr/local/bin/argocd\n\n##### Useful bash Aliases\ncat &lt;&lt; EOF &gt;&gt; ~/.zshrc\nalias tg='terragrunt'\nalias tf='terraform'\nalias tga='terragrunt run-all'\n\nalias kk='kubectl get po -w -o wide'\nalias k='kubectl'\nalias ctx='kubectl ctx'\nalias kns='kubectl ns'\nEOF\n</code></pre>"}]}